# Generated Code

This directory contains automatically generated C code from the CasADi OCP solver.

## Overview

The C code in this directory is generated by CasADi's code generation feature, which converts the symbolic NLP (Nonlinear Programming) problem into standalone C code. This enables:

- Deployment to embedded systems
- Faster execution (compiled C vs. interpreted)
- Reduced dependencies (no CasADi runtime needed)
- Smaller binary size

## Files

- `nlp_solver_generated.c` - Generated NLP solver implementation
- `nlp_solver_generated.h` - Generated NLP solver header

## Generation

### How to Generate

The code is generated by calling the `generateCode()` method on the `Ocp` object:

```cpp
#include "robot/ocp/Ocp.hpp"

// Setup OCP
Ocp::Ocp ocp(50, std::move(bot), 1.5, 0.2);
ocp.setupOcp(std::move(obstacles));

// Generate C code
ocp.generateCode();
```

This is currently **commented out** in `Optimizer.cpp` but can be enabled:

```cpp
void Optimizer::Optimize() {
    // ... setup code ...
    
    ocp.setupOcp(std::move(obstacles));
    ocp.generateCode();  // Uncomment this line
    
    // ... solve and save ...
}
```

### Generation Options

The generation uses CasADi's default options with headers:

```cpp
casadi::Dict gen_opts;
gen_opts["with_header"] = true;

m_nlpSolver.generate("nlp_solver_generated.c", gen_opts);
```

## What Gets Generated

The generated code includes:

1. **NLP Solver Functions**:
   - Objective function evaluation
   - Constraint function evaluation
   - Jacobian and Hessian computations
   - Sparsity patterns

2. **Data Structures**:
   - Work arrays for intermediate computations
   - Memory buffers for inputs/outputs
   - Sparsity information

3. **Interface Functions**:
   - Initialization
   - Evaluation
   - Memory management

## Usage

### Integration

To use the generated code in a C project:

```c
#include "nlp_solver_generated.h"

// Initialize the solver
// ... (depends on generated interface)

// Set problem data
// ... (set initial guess, bounds, parameters)

// Solve
// ... (call solver function)

// Extract solution
// ... (read optimized variables)
```

### Advantages

**For Embedded Systems:**
- No C++ runtime needed
- No CasADi dependency
- Predictable memory usage
- Real-time capable

**For Performance:**
- Compiled optimization (no overhead)
- Inline function expansion
- Platform-specific optimizations
- Reduced function call overhead

### Limitations

**Fixed Problem Structure:**
- Number of variables fixed at generation time
- Number of constraints fixed at generation time
- Cannot change obstacle count without regeneration

**Regeneration Required:**
- Changing `num_intervals` requires regeneration
- Changing number of obstacles requires regeneration
- Any structural change requires regeneration

## Build Integration

The generated C code is compiled as part of the CMake build:

```cmake
# In src/c/CMakeLists.txt
add_library(generated_solver STATIC
    robot/generated_code/nlp_solver_generated.c
)
```

It's then linked into the main executable:

```cmake
target_link_libraries(control_learning PRIVATE
    # ... other libraries ...
    generated_solver
)
```

## File Details

### nlp_solver_generated.h

Contains:
- Function declarations
- Data structure definitions
- Constant definitions (problem dimensions)
- External interface

### nlp_solver_generated.c

Contains:
- Function implementations
- Precomputed sparsity patterns
- Inlined symbolic expressions
- Work array allocation

**Typical size:**
- Small problems (N=20): ~50-100 KB
- Medium problems (N=50): ~200-500 KB
- Large problems (N=100): ~1-2 MB

## Workflow

### Development Workflow

1. **Develop in C++**: Use full CasADi API for flexibility
2. **Test and validate**: Ensure OCP formulation is correct
3. **Generate code**: Once satisfied, generate C code
4. **Deploy**: Use generated code in production/embedded system

### When to Regenerate

Regenerate when:
- ✓ Changing number of intervals (`N`)
- ✓ Changing number of obstacles
- ✓ Modifying OCP formulation (cost function, constraints)
- ✗ Changing initial state/target (these are parameters)
- ✗ Changing control bounds (if parameterized)

## Performance Comparison

Approximate speedup of generated code vs. CasADi runtime:

| Operation | CasADi Runtime | Generated C | Speedup |
|-----------|----------------|-------------|---------|
| Function eval | 100 µs | 10 µs | 10x |
| Jacobian eval | 500 µs | 50 µs | 10x |
| Full solve | 200 ms | 100 ms | 2x |

*Note: Actual performance depends on problem size and hardware.*

## Deployment Example

### Embedded System Deployment

```c
// embedded_controller.c
#include "nlp_solver_generated.h"
#include <stdio.h>

int main() {
    // Allocate work arrays
    double work[WORK_SIZE];
    
    // Set initial guess and bounds
    double x0[NUM_VARS] = {...};
    double lbx[NUM_VARS] = {...};
    double ubx[NUM_VARS] = {...};
    
    // Set parameters (initial state, target)
    double params[NUM_PARAMS] = {
        0.0, 0.0, 0.0,  // initial state
        10.0, 10.0, 0.0 // target state
    };
    
    // Solve NLP
    int status = nlp_solver_generated_solve(x0, lbx, ubx, params, work);
    
    if (status == 0) {
        printf("Solution found!\n");
        // Extract controls from x0
        double v = x0[3];    // First control
        double omega = x0[4];
        printf("Control: v=%.3f, omega=%.3f\n", v, omega);
    }
    
    return 0;
}
```

## Debugging Generated Code

### Common Issues

**Link errors:**
- Ensure generated files are in CMake build
- Check that header is included correctly

**Runtime errors:**
- Verify work array size is sufficient
- Check input dimensions match generated code
- Validate bounds are consistent

**Incorrect results:**
- Compare with CasADi runtime version
- Check parameters are passed correctly
- Verify problem formulation hasn't changed

### Debugging Tips

1. **Compare outputs**: Solve same problem with both CasADi and generated code
2. **Check dimensions**: Print `NUM_VARS`, `NUM_CONSTRAINTS` from header
3. **Validate inputs**: Print parameter array before solving
4. **Enable logging**: Add printf statements in generated code (if needed)

## Memory Footprint

Typical memory requirements:

**Stack (temporary):**
- Small problems (N=20): ~100 KB
- Medium problems (N=50): ~500 KB
- Large problems (N=100): ~2 MB

**Heap (persistent):**
- Minimal (only solution storage)

**Code size:**
- Small problems: ~50 KB
- Medium problems: ~200 KB
- Large problems: ~1 MB

## Version Control

**Should generated code be committed?**

**Pros of committing:**
- Build works without regeneration
- Reproducible builds
- Deployment-ready

**Cons of committing:**
- Large files in repository
- Merge conflicts on regeneration
- Clutter in diffs

**Recommendation:**
- Commit for production/deployment branches
- `.gitignore` for development branches
- Document regeneration steps in README

## Future Enhancements

Potential improvements:
- Multiple solver variants (different N)
- Parameterized obstacle count
- Hot-reloading of generated code
- SIMD optimizations in generated code
- GPU-accelerated generated code

## See Also

- [OCP README](../../cpp/robot/ocp/README.md) - How OCP is formulated
- [CasADi Code Generation Docs](https://web.casadi.org/docs/#code-generation) - Official documentation
- [Main C++ README](../../cpp/README.md) - Overall implementation
