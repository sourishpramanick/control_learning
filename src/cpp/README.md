# C++ Implementation

This directory contains the main C++ implementation of the control learning project, including robot dynamics, optimal control problem formulation, and trajectory optimization.

## Overview

The C++ implementation provides high-performance optimal control and trajectory planning for a differential drive robot using CasADi and IPOPT. It includes:

- Robot dynamics modeling with Runge-Kutta discretization
- Optimal Control Problem (OCP) formulation and solving
- Model Predictive Control (MPC) for real-time control
- Obstacle avoidance constraints
- JSON-based configuration and output

## Directory Structure

```
cpp/
├── main.cpp                    # Main application entry point
├── robot/
│   ├── dynamics/              # Robot dynamics implementation
│   │   ├── include/Model.hpp  # Model class header
│   │   └── Model.cpp          # Model implementation
│   ├── ocp/                   # Optimal control problem
│   │   ├── Ocp.hpp           # OCP class header
│   │   ├── Ocp.cpp           # OCP implementation
│   │   ├── Optimizer.hpp     # Optimizer class header
│   │   └── Optimizer.cpp     # Optimizer implementation
│   ├── environment/          # Environment configuration files
│   │   ├── initial_state.json
│   │   ├── target.json
│   │   └── obstacles.json
│   └── data/
│       └── parameters.json   # Robot parameters
└── utilities/                # Utility functions
    ├── Utilities.hpp
    └── Utilities.cpp
```

## Main Components

### main.cpp

The application entry point. Calls the optimizer to solve the OCP or run MPC.

```cpp
int main() {
    Ocp::Optimizer::Optimize();  // Solve single OCP
    // Ocp::Optimizer::MPC();    // Or run MPC loop
    return 0;
}
```

### Detailed Component Documentation

- [Robot Dynamics](robot/dynamics/README.md) - Model class and dynamics implementation
- [Optimal Control Problem](robot/ocp/README.md) - OCP formulation and solver
- [Environment Configuration](robot/environment/README.md) - Configuration files
- [Utilities](utilities/README.md) - Helper functions

## Building

### Using the build script

```bash
# From project root
./build_and_run.sh
```

### Manual build

```bash
# Install dependencies with Conan
mkdir build && cd build
conan install .. --build=missing

# Configure and build
cmake .. --preset conan-release
cmake --build .

# Run
./control_learning
```

## Dependencies

The project uses the following libraries (managed via Conan):

- **CasADi**: Symbolic framework for automatic differentiation and optimization
- **fmt**: Modern C++ formatting library
- **nlohmann_json**: JSON parsing and serialization

## Usage

### Single Optimization

Solves the OCP once from initial state to target, avoiding obstacles.

```cpp
Ocp::Optimizer::Optimize();
```

**Process:**
1. Loads configuration from JSON files
2. Creates robot model with parameters
3. Sets up OCP with obstacles and constraints
4. Solves optimization problem using IPOPT
5. Extracts and saves solution to `ocp_solution.json`

### Model Predictive Control

Runs MPC loop, repeatedly solving OCP and updating state.

```cpp
Ocp::Optimizer::MPC();
```

**Process:**
1. Loads initial state and target
2. Solves OCP for current state
3. Applies first control input
4. Updates state using dynamics
5. Repeats until target reached
6. Saves trajectory to `robot_sim.json`

## Configuration

### Robot Parameters (`robot/data/parameters.json`)

```json
{
  "parameters": {
    "wheel_base": 0.5,
    "max_velocity": 2.0,
    "min_velocity": -1.0,
    "max_angular_velocity": 1.0,
    "min_angular_velocity": -1.0
  },
  "dynamics": {
    "discretization_step_size": 0.1
  }
}
```

### Environment Configuration

See [Environment README](robot/environment/README.md) for details on:
- Initial state configuration
- Target specification
- Obstacle definition

## Output

### ocp_solution.json

Generated by single optimization, contains:
- Full state trajectory `[x, y, theta]`
- Full control trajectory `[v, omega]`
- Metadata (intervals, timestep, etc.)

### robot_sim.json

Generated by MPC, contains:
- Simulated trajectory from MPC
- Applied control sequence
- Same format as `ocp_solution.json`

Both can be visualized using the scripts in `/scripts` directory.

## Algorithm Details

### Optimal Control Problem Formulation

**Decision Variables:**
- State trajectory: `X = [x₀, y₀, θ₀, x₁, y₁, θ₁, ..., xₙ, yₙ, θₙ]`
- Control trajectory: `U = [v₀, ω₀, v₁, ω₁, ..., vₙ₋₁, ωₙ₋₁]`

**Objective Function:**
```
minimize: Σ(||state - target||² + ||control||²) + ||final_state - target||²_Qf
```

**Constraints:**
1. **Initial state**: `x₀ = x_init`
2. **Dynamics**: `xₖ₊₁ = f(xₖ, uₖ, dt)` (discretized)
3. **Control bounds**: `uₘᵢₙ ≤ uₖ ≤ uₘₐₓ`
4. **Obstacle avoidance**: `(x-xₒ)² + (y-yₒ)² ≥ (r+margin)²`

**Solver:** IPOPT (Interior Point OPTimizer)

### Discretization

Uses 4th-order Runge-Kutta method with 5 integration steps per interval via CasADi's `simpleRK()`.

## Performance

Typical solve times (on modern CPU):
- Single OCP (50 intervals): ~0.1-0.5 seconds
- MPC iteration (20 intervals): ~0.05-0.2 seconds

## Code Generation

The OCP solver can generate standalone C code:

```cpp
ocp.generateCode();  // Generates src/c/robot/generated_code/nlp_solver_generated.c
```

This creates a dependency-free C implementation of the NLP solver for embedded deployment.

## Troubleshooting

**Build Issues:**
- Ensure Conan is installed: `pip install conan`
- Clear Conan cache: `conan remove "*" -c`
- Use correct CMake preset: `--preset conan-release`

**Runtime Issues:**
- Check JSON file paths are correct
- Verify IPOPT can find initial feasible point
- Reduce number of intervals if solver fails
- Check obstacle constraints aren't too tight

## Further Reading

- CasADi documentation: https://web.casadi.org/
- IPOPT documentation: https://coin-or.github.io/Ipopt/
